# 节目编辑器前端架构设计

## 1. 核心模块划分

### 1.1 画布编辑器模块 (CanvasEditor)
```typescript
interface CanvasEditor {
  // 画布管理
  canvas: Fabric.Canvas;
  viewport: { width: number; height: number; scale: number };
  
  // 元素操作
  addElement(element: ProgramElement): void;
  removeElement(id: string): void;
  updateElement(id: string, properties: Partial<ProgramElement>): void;
  
  // 选择和变换
  selectElement(id: string): void;
  multiSelect(ids: string[]): void;
  transformElement(id: string, transform: Transform): void;
  
  // 图层管理
  bringToFront(id: string): void;
  sendToBack(id: string): void;
  setLayer(id: string, layer: number): void;
}

interface ProgramElement {
  id: string;
  type: 'region' | 'item';
  itemType?: ItemType; // 素材类型：IMAGE, VIDEO, TEXT等
  position: { x: number; y: number };
  size: { width: number; height: number };
  properties: ElementProperties;
  materialRef?: MaterialReference;
}

interface MaterialReference {
  materialId: string;
  fileId: string;
  materialType: string;
  accessUrl: string;
  md5Hash: string;
}
```

### 1.2 素材库面板模块 (MaterialLibrary)
```typescript
interface MaterialLibrary {
  // 素材分类浏览
  categories: MaterialCategory[];
  currentCategory: string;
  
  // 素材搜索和筛选
  searchMaterials(keyword: string, filters: MaterialFilter): Promise<Material[]>;
  
  // 素材预览
  previewMaterial(materialId: string): MaterialPreview;
  
  // 拖拽支持
  enableDragDrop(): void;
  onDragStart(material: Material): DragData;
}

interface MaterialCategory {
  id: string;
  name: string;
  type: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'TEXT' | 'VIRTUAL';
  count: number;
  children?: MaterialCategory[];
}
```

### 1.3 属性配置面板模块 (PropertyPanel)
```typescript
interface PropertyPanel {
  // 选中元素属性
  selectedElement: ProgramElement | null;
  
  // 属性编辑器
  renderPropertyEditor(element: ProgramElement): React.ReactNode;
  updateProperty(property: string, value: any): void;
  
  // 专用属性编辑器
  imagePropertyEditor: ImagePropertyEditor;
  videoPropertyEditor: VideoPropertyEditor;
  textPropertyEditor: TextPropertyEditor;
  layoutPropertyEditor: LayoutPropertyEditor;
}

// 图片属性编辑器
interface ImagePropertyEditor {
  alpha: number; // 透明度
  reserveAS: boolean; // 是否缩放
  duration: number; // 播放时长
  ineffect: Effect; // 入场特效
}

// 文本属性编辑器  
interface TextPropertyEditor {
  text: string;
  textColor: string;
  logFont: LogFont;
  isScroll: boolean;
  scrollSpeed: number;
  alignment: 'left' | 'center' | 'right';
}
```

## 2. 状态管理架构

### 2.1 全局状态设计 (Zustand Store)
```typescript
interface ProgramEditorStore {
  // 节目基础信息
  program: {
    id: string;
    name: string;
    width: number;
    height: number;
    createdAt: Date;
    updatedAt: Date;
  };
  
  // 节目页面数据
  pages: ProgramPage[];
  currentPageIndex: number;
  
  // 画布状态
  canvas: {
    zoom: number;
    panX: number;
    panY: number;
    selectedElements: string[];
    clipboard: ProgramElement[];
  };
  
  // 编辑历史
  history: {
    undoStack: EditorAction[];
    redoStack: EditorAction[];
    canUndo: boolean;
    canRedo: boolean;
  };
  
  // 操作方法
  actions: {
    // 节目操作
    createProgram: (info: ProgramInfo) => void;
    updateProgram: (updates: Partial<ProgramInfo>) => void;
    saveProgram: () => Promise<void>;
    
    // 页面操作
    addPage: (page: ProgramPage) => void;
    removePage: (index: number) => void;
    switchPage: (index: number) => void;
    
    // 元素操作
    addElement: (element: ProgramElement) => void;
    updateElement: (id: string, updates: Partial<ProgramElement>) => void;
    removeElement: (id: string) => void;
    
    // 历史操作
    undo: () => void;
    redo: () => void;
    pushAction: (action: EditorAction) => void;
  };
}

interface ProgramPage {
  id: string;
  name: string;
  duration: number; // appointDuration
  loopType: 0 | 1; // 0=指定时长，1=自动计算
  bgColor: string;
  bgFile?: BgFile;
  bgAudios?: BgAudio[];
  regions: Region[];
}

interface Region {
  id: string;
  name: string;
  rect: DisplayRect;
  items: Item[];
  layer?: number;
  isScheduleRegion: boolean;
}
```

## 3. 组件架构设计

### 3.1 主编辑器组件
```typescript
const ProgramEditor: React.FC = () => {
  return (
    <div className="program-editor">
      <ProgramEditorHeader />
      <div className="editor-body">
        <MaterialLibraryPanel />
        <CanvasWorkspace />  
        <PropertyPanel />
      </div>
      <ProgramEditorFooter />
    </div>
  );
};

const CanvasWorkspace: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { program, currentPage } = useProgramStore();
  
  return (
    <div className="canvas-workspace">
      <CanvasToolbar />
      <div className="canvas-container">
        <canvas 
          ref={canvasRef}
          width={program.width}
          height={program.height}
        />
        <CanvasRuler />
        <CanvasGrid />
      </div>
      <PageTabs />
    </div>
  );
};
```

### 3.2 素材库集成组件
```typescript
const MaterialLibraryPanel: React.FC = () => {
  const { materials, loading } = useMaterialQuery();
  
  return (
    <div className="material-library">
      <MaterialSearch />
      <MaterialCategoriesTree />
      <MaterialGrid 
        materials={materials}
        onDragStart={handleMaterialDrag}
        onPreview={handleMaterialPreview}
      />
    </div>
  );
};

const MaterialGrid: React.FC<MaterialGridProps> = ({ materials, onDragStart }) => {
  return (
    <div className="material-grid">
      {materials.map(material => (
        <MaterialCard
          key={material.mid}
          material={material}
          draggable
          onDragStart={() => onDragStart(material)}
          onClick={() => handleAddToCanvas(material)}
        />
      ))}
    </div>
  );
};
```

## 4. 画布渲染引擎选择

### 4.1 Fabric.js 集成方案
```typescript
class FabricCanvasManager {
  private fabric: fabric.Canvas;
  
  constructor(canvasElement: HTMLCanvasElement) {
    this.fabric = new fabric.Canvas(canvasElement, {
      width: 1920,
      height: 1080,
      backgroundColor: '#000000'
    });
    
    this.setupEventListeners();
  }
  
  // 添加素材到画布
  addMaterial(material: Material, position: { x: number, y: number }): void {
    switch (material.materialType) {
      case 'IMAGE':
        this.addImageElement(material, position);
        break;
      case 'VIDEO':
        this.addVideoElement(material, position);
        break;
      case 'TEXT':
        this.addTextElement(material, position);
        break;
    }
  }
  
  private addImageElement(material: Material, position: { x: number, y: number }): void {
    fabric.Image.fromURL(material.accessUrl, (img) => {
      img.set({
        left: position.x,
        top: position.y,
        selectable: true,
        hasControls: true,
        hasBorders: true
      });
      
      // 绑定素材元数据
      img.set('materialData', {
        materialId: material.mid,
        fileId: material.fileId,
        materialType: material.materialType
      });
      
      this.fabric.add(img);
    });
  }
}
```

### 4.2 事件处理机制
```typescript
interface CanvasEventHandler {
  // 选择事件
  onSelectionCreated: (e: fabric.IEvent) => void;
  onSelectionUpdated: (e: fabric.IEvent) => void;
  onSelectionCleared: (e: fabric.IEvent) => void;
  
  // 对象变换事件
  onObjectModified: (e: fabric.IEvent) => void;
  onObjectMoving: (e: fabric.IEvent) => void;
  onObjectScaling: (e: fabric.IEvent) => void;
  
  // 拖拽事件
  onDragOver: (e: DragEvent) => void;
  onDrop: (e: DragEvent) => void;
}
```

## 5. 与后端服务集成

### 5.1 API 客户端设计
```typescript
class ProgramEditorAPI {
  // 节目CRUD
  async createProgram(program: CreateProgramRequest): Promise<Program>;
  async updateProgram(id: string, updates: UpdateProgramRequest): Promise<Program>;
  async getProgram(id: string): Promise<Program>;
  async deleteProgram(id: string): Promise<void>;
  
  // 素材集成
  async searchMaterials(query: MaterialSearchQuery): Promise<Material[]>;
  async getMaterialPreview(materialId: string): Promise<MaterialPreview>;
  
  // VSN生成
  async generateVSN(programId: string): Promise<VSNGenerationResult>;
  async previewProgram(programId: string): Promise<ProgramPreview>;
  
  // 实时协作
  setupWebSocket(programId: string): WebSocketConnection;
}
```

### 5.2 数据同步策略
```typescript
// 使用 React Query 进行服务端状态管理
const useProgramData = (programId: string) => {
  return useQuery({
    queryKey: ['program', programId],
    queryFn: () => api.getProgram(programId),
    staleTime: 5 * 60 * 1000, // 5分钟
    refetchOnWindowFocus: false
  });
};

// 使用 mutation 进行数据更新
const useSaveProgram = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (program: Program) => api.updateProgram(program.id, program),
    onSuccess: (data, variables) => {
      queryClient.setQueryData(['program', variables.id], data);
      toast.success('节目保存成功');
    },
    onError: (error) => {
      toast.error('节目保存失败');
    }
  });
};
```

这个前端架构设计考虑了：
1. **模块化设计**：清晰的职责分离
2. **状态管理**：使用Zustand进行全局状态管理
3. **画布渲染**：基于Fabric.js的高性能渲染
4. **素材集成**：与现有素材管理系统的无缝集成  
5. **实时协作**：支持多用户协同编辑
6. **TypeScript**：完整的类型安全保障